# coding=gbk
"""
公众号文章：范纳斯特 2023-08-03
《常用正则表达式速查手册，建议收藏！》
"""

# 附表 基本知识
"""
元字符
描述

\
转义字符；如"\\n"匹配“\n”, 而简单的“\n”会匹配换行符

^
匹配输入字符的行首 # 如果设置了RefExp对象的Multiline属性，则也会匹配\n和\r的后面的位置

$
匹配输入字符的行尾 # 如果设置了RefExp对象的Multiline属性，则也会匹配\n和\r的前面的位置

*
匹配前面的子表达式的任意次；如“zo*”既可以匹配“z”,也能匹配"zo",以及“zoo”,...(任意多个o)  # * 等价于{0,}

+
匹配前面的子表达式一次或多次(总之得大于等于1次)；例如 "zo+"能匹配“zo”或"zoo"或...，但不能匹配"z"; # + 等价于{1,}

?
①匹配前面的子表达式零次或一次， 例如 "do(es)?"可以匹配"do"和"does"； # ? 等价于{0,1}
②当该字符紧跟在任何一个其他限制字符[* + ? {n} {n,} {n,m}]后面时，匹配模式是“非贪婪模式”，“非贪婪模式”会尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串
    例如，对于字符串"oooo"，"o+"将尽可能多地匹配"o" 得到结果["oooo"]，而"o+?"将尽可能少地匹配"o" 得到结果["o", "o", "o", "o"]

{n}
n是一个非负整数，匹配确定的n次。例如 "o{2}"不能匹配"Bob"中的"o"，但能匹配"food"中的两个"o"

{n,}
n是一个非负整数，至少匹配n次。 例如 "o{2,}"不能匹配"Bob"中的"o"，但能匹配"foooood"中的所有"o"; 
"o{1,}"等价于"o+"
"o{0,}"等价于"o*"

{n,m} # 逗号和两个数字之间不能有空格
m和n均为非负整数，其中n<=m; 最少匹配n次 且 最多匹配m次

.
匹配除了"\n"和"\r"以外的任何单个字符

(?:pattern)
# (pattern) 匹配pattern并获取这一匹配
非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用
例如 "industr(?:y|ies)"就是比“industry|industries”更简略的表达式

(?=pattern)
非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用
例如 “windows(?=95|98|NT|2000)”能匹配"windows2000"中的"windows", 但不能匹配"windows3.1"中的"windows"
预查不消耗字符，也就是说 在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始

(?!pattern)
非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用
例如 "windows(?!95|98|NT|2000)"能匹配"windows3.1"中的"windows"，但不能匹配"windows2000"中的"windows"

(?<=pattern)
非获取匹配，反向否定预查，和正向肯定预查类似，只不过是方向相反
例如 "(?<=95|98|NT|2000)windows"能匹配"2000windows"中的"windows"，但不能匹配"3.1windows"中的"windows"

(?<!pattern)
非获取匹配，反向否定预查，和正向否定预查类似，只是方向相反
例如 "(?<!95|98|NT|2000)windows"能匹配"3.1windows"中的"windows"，但不能匹配"2000windows"中的"windows"

x|y
匹配x或y
例如 "z|food"能匹配"z"或"food"
# "[z|f]ood" 则匹配"zood"或"food"

[xyz]
字符集合
匹配所包含的任意一个字符

[^xyz]
负值字符集合
匹配未包含的任意字符

[a-z]
字符范围
匹配指定范围内的任意字符
例如 "[a-z]"可以匹配a-z范围内的任意小写字母字符

[^a-z]
字符范围
匹配任何不在指定范围内的任意字符
例如 "[^a-z]"可以匹配任何不在a-z范围内的任意字符

\b
匹配一个单词的边界，也就是指单词和空格之间的位置
例如 "er\b"可以匹配"never"中的"er"，但不能匹配"verb"中的"er"
    "\b1"可以匹配"1_23"中的"1_"，但不能匹配"21_3"中的"1_"

\B
匹配非单词边界
例如 "er\B"能匹配"verb"中的"er"， 但不能匹配"never"中的"er"

\d
匹配一个数字字符，等价于 [0-9]

\D
匹配一个非数字字符，等价于 [^0-9]

\f
匹配一个换页符

\n
匹配一个换行符

\r
匹配一个回车符

\t
匹配一个制表符

\v
匹配一个垂直制表符

\s
匹配任何不可见的字符，等价于 [\f\n\r\t\v]

\S
匹配任何可见的字符， 等价于 [^ \f\n\r\t\v]

\w
匹配任何单词Unicode字符(包含下划线)， 类似于 [A-Za-z0-9_]

\W
和\w相反

\num
num是一个正整数
例如 "(.)\1"匹配连续两个相同的字符

()
将()内的表达式定义为“组”，并且将匹配这个表达式的字符保存到一个临时区域
一个正则表达式中最多保存9个组，可以用\1到\9的符号来引用

|
将两个匹配条件进行OR运算

修饰符
    re.l 是匹配对大小写不敏感
    re.M 多行匹配，会影响^和$
    re.S 使.匹配包括换行在内的所有字符
    
为什么有时候要在正则字符串前加"r"
这是为了告诉编译器这个string是个raw string，不要转义反斜杠
例如 在raw string里"\n"就是两个字符，而非代表换行的意思

"""

import re
"""
一些可以用来参考的校验表达式
"""

# 若匹配成功 re.match 方法返回一个匹配的对象，否则返回 None
# 检验输入的内容是否为纯数字 不填不算错
print(re.match('^[0-9]*$', ''))

# 检验输入的内容是否为N位数字
print(re.match('^\d{4}$', '123a'))
print(re.match('^[0-9]{3}$', '123'))

# 至少得输入N位数字，且只能是数字
print(re.match('^\d{5,}$', '12313a'))
# 如果是“M-N位数字，则替换成 {m,n}”

# 零或大于等于三的数字开头的纯数字
print(re.match('^(0|[3-9][0-9]*)$', '412311'))

# 非零开头的数字，且最多带两位小数的纯数字
print(re.match('(^[1-9][0-9]*)((\.[0-9]{1,2})?$)', '11.25'))

# 检验输入的内容是不是纯汉字
print(re.match('^[\u4e00-\u9fa5]{0,}$', '你好'))
# /[\u4E00-\u9FA5]/ 汉字
# /[\uFF00-\uFFFF]/ 全角符号
# /[\u0000-\u00FF]/ 半角符号
